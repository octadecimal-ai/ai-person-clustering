# ğŸ¯ CURSOR RULES - System Grupowania OsÃ³b na ZdjÄ™ciach

## ğŸš¨ OBLIGATORYJNE ZASADY REALIZACJI PLANU

**UWAGA: Te zasady sÄ… nadrzÄ™dne wzglÄ™dem wszystkich innych i MUSZÄ„ byÄ‡ przestrzegane podczas realizacji kaÅ¼dego etapu!**

### ğŸ“‹ Proces realizacji etapÃ³w:
1. **PRZED REALIZACJÄ„ ETAPU**: 
   - Przeanalizuj etap z PLAN.MD
   - Napisz uÅ¼ytkownikowi jakie sÄ… ewentualne trudnoÅ›ci
   - WskaÅ¼ gdzie moÅ¼esz potrzebowaÄ‡ pomocy
   - SprawdÅº czy potrzebujesz API keys, haseÅ‚, kont - zapytaj o nie PRZED rozpoczÄ™ciem
   - Upewnij siÄ™, Å¼e masz wszystkie wymagane dane

2. **PODCZAS REALIZACJI**:
   - Staraj siÄ™ robiÄ‡ sam jak najwiÄ™cej
   - Po kaÅ¼dej nowej funkcjonalnoÅ›ci rÃ³b test
   - Testuj wszystkie moÅ¼liwe przypadki brzegowe
   - Dokumentuj kod zgodnie z zasadami

3. **PO ZAKOÅƒCZENIU ETAPU**:
   - UzupeÅ‚nij PLAN.MD o informacjÄ™ jak zostaÅ‚ zrealizowany etap
   - Dodaj jakie wystÄ…piÅ‚y trudnoÅ›ci i jak je rozwiÄ…zano
   - Oznacz ukoÅ„czone punkty jako âœ… z datÄ…
   - Przygotuj commit z opisem co zostaÅ‚o zrealizowane
   - NIE rÃ³b push - tylko commit

### âš ï¸ ZASADA FUNDAMENTALNA:
**NIGDY nie mÃ³w, Å¼e zakoÅ„czyÅ‚eÅ› jakiÅ› etap, jeÅ›li nie przetestowaÅ‚eÅ› wczeÅ›niej wszelkich moÅ¼liwych funkcjonalnoÅ›ci i przypadkÃ³w brzegowych!**

Testowanie musi obejmowaÄ‡:
- âœ… FunkcjonalnoÅ›Ä‡ podstawowÄ…
- âœ… Przypadki brzegowe (edge cases)
- âœ… ObsÅ‚ugÄ™ bÅ‚Ä™dÃ³w
- âœ… WydajnoÅ›Ä‡ na rÃ³Å¼nych danych
- âœ… KompatybilnoÅ›Ä‡ (rÃ³Å¼ne systemy/hardware)

### ğŸ“Š Aktualizacja PLAN.MD:
Po kaÅ¼dym etapie dodaj sekcjÄ™:
```markdown
### âœ… ETAP X - UKOÅƒCZONY (DATA)
**Zrealizowane funkcjonalnoÅ›ci:**
- [ funkcjonalnoÅ›Ä‡ 1 ]
- [ funkcjonalnoÅ›Ä‡ 2 ]

**WystÄ…pione trudnoÅ›ci:**
- [ trudnoÅ›Ä‡ 1 i jak jÄ… rozwiÄ…zano ]

**Testy wykonane:**
- [ typ testu 1 ]
- [ typ testu 2 ]

**Czas realizacji:** X godzin
```

### ğŸ” Wymagane dane zewnÄ™trzne:
Przed rozpoczÄ™ciem sprawdÅº czy potrzebujesz:
- API keys (OpenAI, Hugging Face, etc.)
- Konta (GitHub, Docker Hub, etc.)
- HasÅ‚a/tokeny
- Licencje software
- DostÄ™p do zewnÄ™trznych serwisÃ³w

### ğŸ’» SPECYFIKACJA ÅšRODOWISKA:
- **System**: MacBook Pro M1 16GB RAM z macOS Sequoia 15.5
- **Auto run**: Wszystko moÅ¼na uruchamiaÄ‡ automatycznie
- **Sudo permissions**: JeÅ›li potrzebujesz hasÅ‚a sudo - napisz i uruchom skrypt .sh ktÃ³ry o nie zapyta
- **Hardware compatibility**: PRZED Å›ciÄ…gniÄ™ciem modelu sprawdÅº czy zadziaÅ‚a na Apple Silicon M1
- **Fallback solutions**: JeÅ›li model nie zadziaÅ‚a - podaj alternatywy (API access, inne modele)
- **Open Source requirement**: Wszystko musi byÄ‡ open source

### ğŸ”” SYSTEM ALERTÃ“W:
```bash
# Alert gdy potrzebujesz pomocy uÅ¼ytkownika
afplay /System/Library/Sounds/Ping.aiff

# Alternatywne dÅºwiÄ™ki:
# afplay /System/Library/Sounds/Basso.aiff  # BÅ‚Ä…d
# afplay /System/Library/Sounds/Funk.aiff   # Sukces
```

### ğŸ“Š DANE TESTOWE:
- **Å¹rÃ³dÅ‚o**: ÅšciÄ…gnij z internetu (pÃ³ki co nie ma lokalnych)
- **Wymagania**: 10 osÃ³b po 5 zdjÄ™Ä‡ w rÃ³Å¼nych pozach
- **Cel**: Te same osoby w rÃ³Å¼nych pozach dla testÃ³w klastrowania
- **Format**: JPG/PNG, rÃ³Å¼ne rozdzielczoÅ›ci

---

## ğŸ“‹ KONTEKST PROJEKTU

Ten projekt implementuje zaawansowany system AI do automatycznego grupowania osÃ³b na zdjÄ™ciach uÅ¼ywajÄ…c:
- **Ensemble modeli YOLO** (v8n, v8s, v8m, v8l, v8x) do detekcji osÃ³b
- **Multi-modal feature extraction** (twarze, poza ciaÅ‚a, ubrania, kolory)
- **Inteligentne klastrowanie** (DBSCAN, Agglomerative, Face Similarity)
- **AutoGen integration** (opcjonalnie) dla LLM wsparcia

### GÅ‚Ã³wne komponenty:
- `EnsembleYOLODetector` - wykrywanie osÃ³b multiple modelami
- `AdvancedFeatureExtractor` - ekstrakcja cech wizualnych 
- `IntelligentClustering` - adaptacyjne klastrowanie
- `ComprehensivePersonGroupingSystem` - gÅ‚Ã³wny system orchestrujÄ…cy

---

## ğŸ KONWENCJE KODOWANIA PYTHON

### Styl kodu:
- **PEP 8** compliance z line length 100 znakÃ³w
- **Type hints** dla wszystkich funkcji i metod
- **Docstrings** w formacie Google/NumPy style
- **f-strings** dla formatowania stringÃ³w
- **Pathlib** zamiast os.path dla Å›cieÅ¼ek

### Nazewnictwo:
- Klasy: `PascalCase` (np. `EnsembleYOLODetector`)
- Funkcje/metody: `snake_case` (np. `extract_face_features`)
- StaÅ‚e: `UPPER_SNAKE_CASE` (np. `DEFAULT_CONFIDENCE_THRESHOLD`)
- Prywatne metody: `_private_method`

### Struktura klas:
```python
class ComponentName:
    """Dokumentacja klasy."""
    
    def __init__(self, config: Optional[Dict] = None):
        self.logger = logging.getLogger(__name__)
        # ... inicjalizacja
    
    def public_method(self, param: Type) -> ReturnType:
        """Dokumentacja metody."""
        pass
    
    def _private_method(self) -> None:
        """Metoda prywatna."""
        pass
```

---

## ğŸ¤– ZASADY PRACY Z AI/ML KOMPONENTAMI

### ZarzÄ…dzanie modelami:
- **Lazy loading** - Å‚aduj modele tylko gdy potrzebne
- **Error handling** - graceful degradation jeÅ›li model niedostÄ™pny
- **Device management** - automatyczny dobÃ³r CPU/CUDA/MPS
- **Memory optimization** - zwolnij pamiÄ™Ä‡ po uÅ¼yciu
- **Model versioning** - dokumentuj wersje modeli

### YOLO Models:
```python
# Zawsze uÅ¼ywaj ensemble approach
models = {
    'yolov8x': {'weight': 1.0, 'conf_threshold': 0.25},
    'yolov8l': {'weight': 0.9, 'conf_threshold': 0.3},
    # ...
}

# Weighted NMS dla ensemble results
final_detections = self._weighted_nms(all_detections, iou_threshold=0.6)
```

### Feature Extraction:
- **Multi-modal approach** - zawsze prÃ³buj wszystkie typy cech
- **Fallback mechanisms** - jeÅ›li InsightFace fails, uÅ¼yj face_recognition
- **Feature normalization** - standardyzuj przed klastrowanie
- **Dimensionality consistency** - handle variable feature sizes

### Clustering:
- **Adaptive parameters** - estymuj optymalne parametry z danych
- **Multiple algorithms** - porÃ³wnaj DBSCAN, Agglomerative, custom
- **Quality metrics** - oceÅ„ jakoÅ›Ä‡ klastrowanie przed zwrotem
- **Post-processing** - merge similar clusters, handle noise

---

## ğŸ“ STRUKTURA PLIKÃ“W I ORGANIZACJA

### GÅ‚Ã³wne pliki:
- `person_grouping_system.py` - gÅ‚Ã³wny system z wszystkimi komponentami
- `config.json` - konfiguracja systemu
- `requirements.txt` - dependencies
- `PLAN.MD` - plan realizacji projektu

### Struktura katalogÃ³w:
```
AiPersonClustering/
â”œâ”€â”€ .dev/                    # NarzÄ™dzia deweloperskie
â”‚   â”œâ”€â”€ time.sh             # Skrypt czasu
â”‚   â”œâ”€â”€ snapshot.sh         # Tworzenie patches
â”‚   â””â”€â”€ logs/               # Logi konwersacji
â”œâ”€â”€ models/                 # Modele AI (cache)
â”œâ”€â”€ data/                   # Dane testowe
â”œâ”€â”€ results/                # Wyniki grupowania
â”œâ”€â”€ configs/                # Pliki konfiguracyjne
â””â”€â”€ tests/                  # Testy jednostkowe
```

### Import conventions:
```python
# Standardowe biblioteki
import os
import sys
from pathlib import Path
from typing import List, Dict, Optional, Tuple

# Biblioteki zewnÄ™trzne
import cv2
import numpy as np
import torch
from ultralytics import YOLO

# Biblioteki AI/ML
import face_recognition
import insightface
import mediapipe as mp
from sklearn.cluster import DBSCAN

# Lokalne importy
from .components import EnsembleYOLODetector
```

---

## ğŸ§ª ZASADY TESTOWANIA

### Unit Tests:
- **Jeden test = jedna funkcjonalnoÅ›Ä‡**
- **Mock external dependencies** (models, file I/O)
- **Test edge cases** (empty images, no faces detected)
- **Performance tests** dla czasochÅ‚onnych operacji

### Integration Tests:
- **End-to-end pipeline** z rzeczywistymi obrazami
- **Different scenarios** (portrait, group, sport photos)
- **Hardware compatibility** (CPU, CUDA, MPS)
- **Memory stress tests** dla duÅ¼ych batch

### Test structure:
```python
class TestEnsembleYOLODetector:
    def setup_method(self):
        self.detector = EnsembleYOLODetector(device='cpu')
    
    def test_single_image_detection(self):
        # Test podstawowej funkcjonalnoÅ›ci
        pass
    
    def test_empty_image_handling(self):
        # Test edge case
        pass
```

---

## ğŸ“Š KONFIGURACJA I ZARZÄ„DZANIE

### Config management:
- **JSON configs** dla user-facing parameters
- **Environment variables** dla credentials
- **Default values** w kodzie z moÅ¼liwoÅ›ciÄ… override
- **Validation** parametrÃ³w przed uÅ¼yciem

### Logging:
```python
# UÅ¼ywaj structured logging
self.logger.info(f"Processed {len(persons)} persons in {time:.2f}s", 
                extra={'persons_count': len(persons), 'processing_time': time})

# RÃ³Å¼ne poziomy dla rÃ³Å¼nych informacji
self.logger.debug("Technical details")
self.logger.info("User-relevant information")  
self.logger.warning("Potential issues")
self.logger.error("Actual errors")
```

### Error Handling:
```python
try:
    result = risky_operation()
    return result
except SpecificException as e:
    self.logger.warning(f"Expected issue: {e}")
    return fallback_result()
except Exception as e:
    self.logger.error(f"Unexpected error: {e}")
    raise
```

---

## âš¡ WYDAJNOÅšÄ† I OPTYMALIZACJA

### Memory Management:
- **Process w batch** zamiast pojedynczo
- **Clear cache** po przetworzeniu duÅ¼ych grup
- **Use generators** dla lazy loading duÅ¼ych datasets
- **Monitor memory usage** i warn przy high usage

### GPU Optimization:
- **Batch operations** kiedy moÅ¼liwe
- **Tensor operations** zamiast numpy loops
- **Model switching** minimize dla performance
- **Mixed precision** jeÅ›li supported

### Threading/Multiprocessing:
```python
# Threading dla I/O-bound operations
with ThreadPoolExecutor(max_workers=4) as executor:
    futures = [executor.submit(process_image, path) for path in paths]

# Multiprocessing dla CPU-intensive
with ProcessPoolExecutor(max_workers=cpu_count()) as executor:
    results = list(executor.map(cpu_intensive_func, data))
```

---

## ğŸ”§ NARZÄ˜DZIA DEWELOPERSKIE

### Snapshot system:
```bash
# Po kaÅ¼dej istotnej zmianie
.dev/snapshot.sh opis_zmiany
```

### Time tracking:
```bash
# UÅ¼ywaj przed zapisem timestampÃ³w  
CURRENT_TIME=$(.dev/time.sh)
```

### Logging konwersacji:
- Format: `YYYYMMDD_His_krotki_opis_watku.log`
- Lokalizacja: `.dev/logs/`
- ZawartoÅ›Ä‡: pytanie, analiza, odpowiedÅº, wykonane dziaÅ‚ania

---

## ğŸ“š DOKUMENTACJA

### README updates:
- **Keep in sync** z aktualnÄ… implementacjÄ…
- **Include performance benchmarks** po testach
- **Update installation guide** jeÅ›li dependencies zmieniajÄ… siÄ™
- **Add troubleshooting** dla common issues

### Code comments:
```python
# Dlaczego coÅ› robisz (business logic)
# ensemble approach zwiÄ™ksza accuracy o ~15% 
detections = self._ensemble_detect(image)

# ZÅ‚oÅ¼one algorytmy - jak dziaÅ‚ajÄ…
# Weighted NMS: kombinuje predictions z wagami modeli
# wyÅ¼sze wagi = wiÄ™kszy wpÅ‚yw na final detection
```

### API Documentation:
- **Type hints** dla wszystkich public methods
- **Examples** w docstrings
- **Parameter descriptions** ze units jeÅ›li applicable
- **Return value formats** clearly described

---

## ğŸš¨ SPECJALNE INSTRUKCJE

### Podczas implementacji:
1. **Zawsze testuj** na maÅ‚ym zestawie danych najpierw
2. **Profile performance** dla czasochÅ‚onnych operacji  
3. **Validate results** - czy clusters make sense?
4. **Handle failures gracefully** - system powinien degradowaÄ‡ siÄ™ Å‚agodnie
5. **Document decisions** - dlaczego wybraÅ‚eÅ› konkretne parametry?

### Przed commit:
1. **Run tests** - przynajmniej unit tests pass
2. **Check memory usage** - no memory leaks
3. **Validate configs** - default config dziaÅ‚a
4. **Update PLAN.MD** - mark completed items âœ…
5. **Create snapshot** - `.dev/snapshot.sh description`

### Debug mode:
```python
# WÅ‚Ä…cz gdy debugging
config['save_debug_images'] = True
config['verbose_logging'] = True 
config['save_intermediate_results'] = True
```

---

## ğŸ¯ PRIORYTETY

1. **WYSOKIE**: Podstawowa funkcjonalnoÅ›Ä‡ (detection â†’ features â†’ clustering)
2. **ÅšREDNIE**: Optymalizacja, wizualizacje, comprehensive reporting
3. **NISKIE**: AutoGen integration, advanced features, deployment

### Quick wins:
- Implementuj simplest version fÃ¸rst
- Add complexity incrementally
- Always maintain working baseline
- Optimize after correctness confirmed

---

*Te zasady powinny byÄ‡ uÅ¼ywane przez wszystkich pracujÄ…cych nad projektem dla spÃ³jnoÅ›ci i jakoÅ›ci kodu.* 